/*
 * This utility takes two major arguments: the name of a sheetset file and the name of a pdf output file.
 * We plot the complete sheetset to the pdf file, using the first entry in the sheetset's list of page setup overrides.
 * 
 * 
 * Internally, the strategy is to read the sheetset file to construct an AutoCAD sheet list file (a *.dsd file, which seems to use the ini format.),
 * and then use the Document.SendCommand function of the Auotcad COM API to send a "-PUBLISH" command to the Autocad shell, along with the path
 * of our newly-constructed dsd file.
 * The Autocad documentation recommends against manually constructing a dsd file, saying that the better way to do it is use the AutoCAD API,
 * because the format of the dsd file is liable to change between versions of AutoCAD.
 * However, the part of the Autocad API that supports generating a dsd file (The AcadApplication.Publisher namespace (or something like that)) is not exposed via COM, 
 * but is only exposed via the ObjectArx API.
 * This means that if we want to use the API to construct the dsd file, we have to deal with the rigamarole of telling AutoCAD, via COM, to load
 * an OBjectARX dll, which we have to create to do the desired constructing of the dsd file.  This seems to me to be more trouble than it is worth -
 * I can imagine that I would have to invent some non-standard, probably buggy, way to communicate with the loaded ObjectARX dll to tell it
 * What files to put in the dsd file.  There may be some way to do this, but I do not have a clear idea of how at the moment.  The most
 * intuitive approach, to my mind, is to construct the dsd file myself.  The dsd format seems to be understandable by glancing at a few examples of dsd 
 * files generated by the Autocad PUBLISH command.
 * 
 */


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Autodesk.AutoCAD.Interop;
using Autodesk.AutoCAD.Interop.Common;
using ACSMCOMPONENTS25Lib;
using System.Runtime.InteropServices;
using CommandLine;
using System.IO;

namespace acad_sheetset_to_pdf
{

    class Program
    {
        public class Options
        {
            [Option(Required = true, HelpText = "The sheetset file to be processed.")]
            public String SheetSetFile { get; set; }

            [Option(Required = true, HelpText = "The pdf file to be generated.")]
            public String OutputPdfFile { get; set; }
        }


        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool SetDllDirectory(string lpPathName);

        [DllImport("kernel32", SetLastError = true)]
        static extern int LoadLibrary(string lpFileName);


        [DllImport("kernel32")]
        public extern static bool FreeLibrary(int hLibModule);

        ///* Returns true when and only when 
        // * acad.GetAcadState().IsQuiescent 
        // * can be evaluated without throwing the RPC_E_CALL_REJECTED 'Call was rejected by callee.'
        // * exception AND when it evaluates to True (we catch and discard the RPC_E_CALL_REJECTED exception).
        // */
        public static bool AcadIsAvailableAndQuiescent(IAcadApplication acad)
        {
            AcadState currentAcadState;
            try
            {
                currentAcadState = acad.GetAcadState();
                return currentAcadState.IsQuiescent;
            }
            catch (System.Runtime.InteropServices.COMException e)
            {
                Console.WriteLine("encountered (and dropped) a COMException while attempting to " +
                    "determine whether the acad application object is quiescent: " + e.ToString()
                );
                // System.Runtime.InteropServices.COMException: 'Call was rejected by callee. (Exception from HRESULT: 0x80010001 (RPC_E_CALL_REJECTED))'
                return false;
            }
        }

        //The [STAThread] statement below was the answer to make the instantiation of the COM objects stop complaining that the interface could not be found.
        [STAThread] 
        static int Main(string[] args)
        {
            Options commandLineOptions = new Options();
            bool parseErrorsOccured = false;

            CommandLine.Parser.Default.ParseArguments<Options>(args)
                .WithParsed<Options>(opts => commandLineOptions = opts)
                .WithNotParsed<Options>((errs) => parseErrorsOccured = true);

            if (parseErrorsOccured) {
                //Console.WriteLine("some parse errors occured. ahoy.");
                return 1;
            }



            //*****parse the command-line arguments*****
            //for now, I will simply hard code these values.
            String nameOfSheetsetFile = commandLineOptions.SheetSetFile;
            String nameOfPdfOutputFile = commandLineOptions.OutputPdfFile;
            String baseName = System.IO.Path.GetTempFileName();
            String nameOfTheTemporaryDsdFile = baseName + ".dsd";
            String nameOfTheTemporaryPlotLogFile = baseName + "-plot" +  ".log";

            //TO DO: parse and verify the real command-line arguments, compose a help message.

            //*****read the sheetset file and construct a dsd file accordingly*****
            IAcSmSheetSetMgr sheetSetMgr;
            IAcSmDatabase sheetdb;
            IAcSmSheetSet sheetSet;

            Console.WriteLine("Getting the AutoCAD aplication object...");

            IAcadApplication acad;
            acad = new AcadApplication();
            acad.Visible = false;
            // to do: figure out how to instantiate acad in such a way that no flashing windows appear.  Even when we set acad.Visibile = false,
            // the layer manager window and other accessory AutoCAD windows sometimes appear.
            //I want to run AutoCAD fully as a background process.
            // would it make sense to use the special command-line version of AutoCAD for this instead of the COM object?  (acconsole.exe, I think)
            String acadProgramDirectory = System.IO.Path.GetDirectoryName(acad.FullName);
            Console.WriteLine("acad.FullName: " + acad.FullName);
            Console.WriteLine("acadProgramDirectory: " + acadProgramDirectory);

            Environment.SetEnvironmentVariable("PATH", Environment.GetEnvironmentVariable("PATH") + ";" + acadProgramDirectory);
            //SetDllDirectory(dllDirectory);

            //Console.WriteLine("Directory.GetCurrentDirectory(): " + Directory.GetCurrentDirectory());
            //Directory.SetCurrentDirectory(dllDirectory);
            //Console.WriteLine("Directory.GetCurrentDirectory(): " + Directory.GetCurrentDirectory());
            //IAcadApplication acad;
            //acad = new AcadApplication();
            Console.WriteLine("checkpoint -2");

            // it seems that we have to arrange to have the following dlls in the same directory as the acad-sheetset-to-pdf executable in order to succesfully create
            // an instance of the AcSmSheetSetMgr object, below.
            // acpal.dll
            // acui24res.dll
            // adui24res.dll
            // anavRes.dll

            //Even if we run executable with the initial working directory being the autocad install directory (which is the primary residence of those dlls), we still get errors about not being able to find entry points.

            int libIdOfAcpal = 0;
            //int libIdOfAcui24res = 0;
            //int libIdOfAdui24res = 0;
            //int libIdOfAnavRes = 0;

            libIdOfAcpal = LoadLibrary(acadProgramDirectory + @"\" + "acpal.dll");
            //libIdOfAcpal = LoadLibrary("acpal.dll"); 
            // for reasons that I do not fully understand, manually loading acpal.dll with the above call to LoadLibrary will prevent the below "new AcSmSheetSetMgr()" statement from throwing an error abot not being able
            // to find dlls.

            //libIdOfAcui24res = LoadLibrary(dllDirectory + @"\" + "acui24res.dll");
            //libIdOfAdui24res = LoadLibrary(dllDirectory + @"\" + "adui24res.dll");
            //libIdOfAnavRes = LoadLibrary(dllDirectory + @"\" + "anavRes.dll");

            Console.WriteLine("libIdOfAcpal: " + libIdOfAcpal);
            //Console.WriteLine("libIdOfAcui24res: " + libIdOfAcui24res);
            //Console.WriteLine("libIdOfAdui24res: " + libIdOfAdui24res);
            //Console.WriteLine("libIdOfAnavRes: " + libIdOfAnavRes);


            sheetSetMgr = new AcSmSheetSetMgr();
            Console.WriteLine("attempting to open " + nameOfSheetsetFile);
            //Environment.CurrentDirectory = @"C:\Program Files\Autodesk\AutoCAD 2019";
            sheetdb = sheetSetMgr.OpenDatabase(nameOfSheetsetFile, bFailIfAlreadyOpen: false);
            Console.WriteLine("checkpoint -1");
            String nameOfDwgFileContainingThePageSetup;
            String nameOfThePageSetup;

            //IAcadApplication acad;
            //acad = new AcadApplication();

            if (sheetdb.GetLockStatus() == 0) { sheetdb.LockDb(sheetdb); } //it may not be necessary to lock the sheetset, because I am only reading from it, not writing to it.
            sheetSet = sheetdb.GetSheetSet();
            if (sheetdb.GetLockStatus() != 0) { sheetdb.UnlockDb(sheetdb); }
            //read the page setup override information from the sheet set.
            nameOfDwgFileContainingThePageSetup = sheetSet.GetAltPageSetups().ResolveFileName();

            Console.WriteLine("checkpoint 0");
            IAcSmNamedAcDbObjectReference myNamedAcDbObjectReference;
            myNamedAcDbObjectReference = sheetSet.GetDefAltPageSetup();
            //nameOfThePageSetup = myNamedAcDbObjectReference.GetName();
            // the above is not working because sheetSet.GetDefAltPageSetup() returns null.
            // I suspect that sheetSet.GetDefAltPageSetup() only returns something when
            // this code is being run within the Autocad process.
            //as a work-around, we might have to open the dwg file containing the page setup, and read out the page setup names from it.
            Console.WriteLine("checkpoint 1");
            
            acad.Visible = false;
            Console.WriteLine("checkpoint 2");
            IAcadDocument documentContainingThePageSetup = acad.Documents.Open(Name: nameOfDwgFileContainingThePageSetup, ReadOnly: true);

            while (!AcadIsAvailableAndQuiescent(acad)  )
            {
                Console.WriteLine("waiting for autoCAD to become available and quiescent.");
            }

            Console.WriteLine("documentContainingThePageSetup.Name: " + documentContainingThePageSetup.Name);		//             documentContainingThePageSetup.Name

            Console.WriteLine("documentContainingThePageSetup.PlotConfigurations.Count: " + documentContainingThePageSetup.PlotConfigurations.Count);       //             documentContainingThePageSetup.PlotConfigurations.Count


            foreach ( IAcadPlotConfiguration thisPlotConfiguration in documentContainingThePageSetup.PlotConfigurations)
            {
                Console.WriteLine("found a PlotConfiguration: " + thisPlotConfiguration.Name);
            }
            nameOfThePageSetup = documentContainingThePageSetup.PlotConfigurations.Item(0).Name;
            documentContainingThePageSetup.Close(SaveChanges: false);
            Console.WriteLine("nameOfDwgFileContainingThePageSetup: " + nameOfDwgFileContainingThePageSetup);
            Console.WriteLine("nameOfThePageSetup: " + nameOfThePageSetup);

            string dsdContent = "";
            dsdContent +=
                "[DWF6Version]" + "\r\n" +
                "Ver=1" + "\r\n" +
                "[DWF6MinorVersion]" + "\r\n" +
                "MinorVer=1" + "\r\n";

            IAcSmEnumComponent myAcSmEnumComponent = sheetSet.GetSheetEnumerator();
            IAcSmComponent thisAcSmComponent;
            IAcSmSheet thisSheet;
            while ((thisAcSmComponent = myAcSmEnumComponent.Next()) != null)
            {
                Console.WriteLine(thisAcSmComponent.GetObjectId().GetPersistObject().GetTypeName());
                thisSheet = (IAcSmSheet) thisAcSmComponent.GetObjectId().GetPersistObject();
                Console.WriteLine("thisSheet.GetName(): " + thisSheet.GetName());		//                 thisSheet.GetName()
                Console.WriteLine("thisSheet.GetLayout().GetName(): " + thisSheet.GetLayout().GetName());		//                 thisSheet.GetLayout().GetName()
                Console.WriteLine("thisSheet.GetLayout().ResolveFileName(): " + thisSheet.GetLayout().ResolveFileName());       //                 thisSheet.GetLayout().ResolveFileName()
                Console.WriteLine("thisSheet.GetLayout().GetFileName(): " + thisSheet.GetLayout().GetFileName());		//                 thisSheet.GetLayout().GetFileName()

                dsdContent +=
                    "[DWF6Sheet:" + thisSheet.GetName() + "]" + "\r\n" +
                    "DWG=" + thisSheet.GetLayout().ResolveFileName() + "\r\n" +
                    "Layout=" + thisSheet.GetLayout().GetName() + "\r\n" +
                    "Setup=" + nameOfThePageSetup + "|" + nameOfDwgFileContainingThePageSetup + "\r\n" +
                    "OriginalSheetPath=" + thisSheet.GetLayout().ResolveFileName() + "\r\n" +
                    "Has Plot Port=" + "0" + "\r\n" + 
                    "Has3DDWF=" + "0" + "\r\n";
            }

            dsdContent +=
                "[Target]" + "\r\n" +
                "Type=6" + "\r\n" +
                "DWF=" + nameOfPdfOutputFile + "\r\n" +
                "OUT=" + System.IO.Path.GetDirectoryName(nameOfPdfOutputFile) /*+ System.IO.Path.DirectorySeparatorChar*/ + "\r\n" + 
                "PWD=" + "" + "\r\n" +
                "[PdfOptions]" + "\r\n" +
                "IncludeHyperlinks=FALSE" + "\r\n" +
                "CreateBookmarks=FALSE" + "\r\n" +
                "CaptureFontsInDrawing=TRUE" + "\r\n" +
                "ConvertTextToGeometry=FALSE" + "\r\n" +
                "VectorResolution=600" + "\r\n" +
                "RasterResolution=400" + "\r\n" +
                "[AutoCAD Block Data]" + "\r\n" +
                "IncludeBlockInfo=0" + "\r\n" +
                "BlockTmplFilePath=" + "\r\n" +
                "[SheetSet Properties]" + "\r\n" +
                "IsSheetSet=TRUE" + "\r\n" +
                "IsHomogeneous=FALSE" + "\r\n" +
                "SheetSet Name=" + sheetSet.GetName() + "\r\n" +
                "NoOfCopies=1" + "\r\n" +
                "PlotStampOn=FALSE" + "\r\n" +
                "ViewFile=FALSE" + "\r\n" +
                "JobID=0" + "\r\n" +
                "SelectionSetName=" + "\r\n" +
                "AcadProfile=" + "\r\n" +
                "CategoryName=" + "\r\n" +
                "LogFilePath=" + nameOfTheTemporaryPlotLogFile + "\r\n" +
                "IncludeLayer=FALSE" + "\r\n" +
                "LineMerge=FALSE" + "\r\n" +
                "CurrentPrecision=" + "\r\n" +
                "PromptForDwfName=FALSE" + "\r\n" +
                "PwdProtectPublishedDWF=FALSE" + "\r\n" +
                "PromptForPwd=FALSE" + "\r\n" +
                "RepublishingMarkups=FALSE" + "\r\n" +
                "DSTPath=" + nameOfSheetsetFile + "\r\n" +
                "PublishSheetSetMetadata=FALSE" + "\r\n" +
                "PublishSheetMetadata=FALSE" + "\r\n" +
                "3DDWFOptions=0 0" + "\r\n" + "\r\n" +
                "";

            System.IO.File.WriteAllText(path: nameOfTheTemporaryDsdFile, contents: dsdContent);

            Console.WriteLine(nameOfTheTemporaryDsdFile);
 
            if (sheetdb.GetLockStatus() != 0){ sheetdb.UnlockDb(sheetdb);}
            IAcadDocument workingDocument = acad.Documents.Add();
            while (acad.GetAcadState().IsQuiescent == false)
            {
                Console.WriteLine("waiting for autoCAD to become quiescent.");
            }
            workingDocument.SetVariable("FILEDIA", 0);
            workingDocument.SendCommand("-PUBLISH" + "\n" + nameOfTheTemporaryDsdFile + "\n");
            

            try
            {
                //make a copy of the log file so that we can inspect the log file even after the clean-up behavior built into AutoCAD's publish routine has deleted the original log file.
                System.IO.File.Copy(nameOfTheTemporaryPlotLogFile, baseName + "2" + "-plot" + ".log", overwrite: true);
                //Actually, the above attempt to copy does not seem to result in the expected output log file.  However, it does seem to result in having a csv version of the log file left behind in the temp folder.
            }
            catch (Exception)
            {
                Console.WriteLine("Attempted and failed to make a copy of the temporary plot log file. " + nameOfTheTemporaryPlotLogFile);
                //throw;
            }
            

            workingDocument.Close(SaveChanges: false);
            while (acad.GetAcadState().IsQuiescent == false)
            {
                Console.WriteLine("waiting for autoCAD to become quiescent.");
            }
            // Keep the console window open
            //Console.WriteLine("Press any key to exit."); Console.ReadKey();
            acad.Quit();

            if (libIdOfAcpal > 0) { FreeLibrary(libIdOfAcpal); }
            //if (libIdOfAcui24res > 0) { FreeLibrary(libIdOfAcui24res); }
            //if (libIdOfAdui24res > 0) { FreeLibrary(libIdOfAdui24res); }
            //if (libIdOfAnavRes > 0) { FreeLibrary(libIdOfAnavRes); }



            return 0;
        }
    }
}
